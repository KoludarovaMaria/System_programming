format ELF executable  ; Формат ELF для исполняемого файла Linux
entry _start           ; Точка входа в программу

segment readable executable  ; Сегмент исполняемого кода

_start:
    mov ebp, esp       ; Сохраняем указатель стека для отладки/профилирования
    
main_loop:             ; Основной цикл программы
    ; Вывод приглашения для ввода команды
    mov eax, 4         ; Системный вызов sys_write (4)
    mov ebx, 1         ; Файловый дескриптор stdout (1)
    mov ecx, prompt    ; Указатель на строку "Введите команду: "
    mov edx, prompt_len ; Длина строки приглашения
    int 0x80           ; Вывод приглашения на экран
    
    ; Чтение ввода пользователя с клавиатуры
    mov eax, 3         ; Системный вызов sys_read (3)
    mov ebx, 0         ; Файловый дескриптор stdin (0)
    mov ecx, input     ; Указатель на буфер для ввода
    mov edx, 255       ; Максимальная длина ввода (255 байт)
    int 0x80           ; Чтение ввода пользователя
    
    ; Проверка на EOF (конец файла) - важно при чтении из pipe/файла
    test eax, eax      ; Проверяем, сколько байт было прочитано
    jz exit_program    ; Если 0 байт (EOF) - завершаем программу
    
    ; Проверка на пустую строку (только символ новой строки)
    cmp eax, 1         ; Сравниваем длину ввода с 1
    jle main_loop      ; Если <= 1 (пустая строка) - возвращаемся к началу цикла
    
    ; Убираем символ новой строки (\n) в конце введенной строки
    mov esi, input     ; ESI указывает на начало буфера ввода
    add esi, eax       ; Добавляем длину ввода - теперь ESI указывает ЗА конец строки
    dec esi            ; Декрементируем - теперь ESI указывает на последний символ
    mov byte [esi], 0  ; Заменяем символ новой строки на нулевой байт (терминатор строки)
    
    ; Проверка на команду "exit" для выхода из шелла
    mov edi, input     ; EDI указывает на начало строки ввода
    cmp byte [edi], 'e' ; Проверяем первый символ
    jne .not_exit      ; Если не 'e' - это не команда exit
    cmp byte [edi+1], 'x' ; Проверяем второй символ
    jne .not_exit      ; Если не 'x' - это не команда exit
    cmp byte [edi+2], 'i' ; Проверяем третий символ
    jne .not_exit      ; Если не 'i' - это не команда exit
    cmp byte [edi+3], 't' ; Проверяем четвертый символ
    jne .not_exit      ; Если не 't' - это не команда exit
    cmp byte [edi+4], 0 ; Проверяем пятый символ (должен быть нулевой)
    je exit_program    ; Если вся строка "exit\0" - завершаем программу
    
.not_exit:             ; Если введена не команда exit
    ; Создаем дочерний процесс с помощью fork()
    mov eax, 2         ; Системный вызов sys_fork (2)
    int 0x80           ; Создаем копию текущего процесса
    
    test eax, eax      ; Проверяем результат fork()
    jz .child_process  ; Если 0 - мы в дочернем процессе
                       ; Иначе в родительском, eax содержит PID дочернего процесса
    
    ; Родительский процесс - ждем завершения дочернего процесса
    push eax           ; Сохраняем PID дочернего процесса в стеке
    mov eax, 7         ; Системный вызов sys_waitpid (7)
    pop ebx            ; Восстанавливаем PID из стека в EBX
    mov ecx, 0         ; Указатель на статус (NULL)
    mov edx, 0         ; Опции (0)
    int 0x80           ; Ждем завершения дочернего процесса
    
    jmp main_loop      ; Возвращаемся к началу основного цикла

.child_process:        ; Код дочернего процесса
    ; Загружаем и выполняем программу с помощью execve()
    mov eax, 11        ; Системный вызов sys_execve (11)
    mov ebx, input     ; Указатель на строку с именем программы (первый аргумент)
    mov ecx, 0         ; Аргументы командной строки (NULL)
    mov edx, 0         ; Переменные окружения (NULL)
    int 0x80           ; Заменяем текущий процесс новой программой
    
    ; Если мы дошли сюда - execve() завершился с ошибкой
    mov eax, 1         ; Системный вызов sys_exit (1)
    mov ebx, 1         ; Код возврата 1 (ошибка)
    int 0x80           ; Завершаем дочерний процесс с ошибкой

exit_program:          ; Выход из программы
    mov eax, 1         ; Системный вызов sys_exit (1)
    mov ebx, 0         ; Код возврата 0 (успех)
    int 0x80           ; Завершаем программу

segment readable writeable  ; Сегмент данных
    prompt db "Введите команду: ", 0  ; Строка приглашения для ввода
    prompt_len = $ - prompt           ; Длина строки приглашения
    input rb 256                      ; Буфер для ввода (256 байт)