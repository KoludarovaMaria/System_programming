format ELF64                      ; Формат 64-битного ELF файла для Linux

section '.data' writable          ; Секция инициализированных данных
    prompt db "Введите n: ", 0    ; Строка приглашения для ввода
    prompt_len = $ - prompt       ; Длина строки приглашения
    result_msg db "Автоморфные числа:", 10, 0 ; Заголовок результата
    result_msg_len = $ - result_msg ; Длина заголовка
    separator db " - ", 0         ; Разделитель между числом и квадратом
    separator_len = $ - separator ; Длина разделителя
    newline db 10                 ; Символ новой строки

section '.bss' writable           ; Секция неинициализированных данных
    n rd 1                        ; Переменная для числа n (4 байта)
    i rd 1                        ; Счетчик цикла i (4 байта)
    digits rd 1                   ; Количество цифр в числе (4 байта)
    power rq 1                    ; Степень 10 (10^digits) (8 байт)
    square rq 1                   ; Квадрат числа (8 байт)
    temp rd 1                     ; Временная переменная (4 байта)
    buffer rb 20                  ; Буфер для ввода (20 байт)
    num_buf rb 20                 ; Буфер для преобразования чисел (20 байт)

section '.text' executable        ; Секция исполняемого кода
public _start                     ; Точка входа программы

_start:
    ; Вывод приглашения для ввода
    mov rax, 1                   ; Системный вызов write (1)
    mov rdi, 1                   ; Файловый дескриптор stdout
    mov rsi, prompt              ; Указатель на строку приглашения
    mov rdx, prompt_len          ; Длина строки приглашения
    syscall                      ; Вызов системного вызова

    ; Чтение числа от пользователя
    mov rax, 0                   ; Системный вызов read (0)
    mov rdi, 0                   ; Файловый дескриптор stdin
    mov rsi, buffer              ; Указатель на буфер для ввода
    mov rdx, 20                  ; Максимальная длина ввода
    syscall                      ; Вызов системного вызова

    ; Преобразование строки в число
    mov rsi, buffer              ; Указатель на начало буфера ввода
    xor rax, rax                 ; Обнуляем RAX (здесь будет результат)
    xor rbx, rbx                 ; Обнуляем RBX
convert_loop:
    mov bl, [rsi]                ; Загружаем текущий символ из буфера
    cmp bl, 10                   ; Проверяем символ новой строки
    je convert_done              ; Если конец строки - выходим из цикла
    sub bl, '0'                  ; Преобразуем символ ASCII в цифру
    imul rax, 10                 ; Умножаем текущий результат на 10
    add rax, rbx                 ; Добавляем новую цифру к результату
    inc rsi                      ; Переходим к следующему символу
    jmp convert_loop             ; Продолжаем цикл преобразования
convert_done:
    mov [n], eax                 ; Сохраняем полученное число в n

    ; Вывод заголовка результата
    mov rax, 1                   ; Системный вызов write
    mov rdi, 1                   ; stdout
    mov rsi, result_msg          ; Указатель на строку заголовка
    mov rdx, result_msg_len      ; Длина строки заголовка
    syscall                      ; Вызов системного вызова

    ; Инициализация счетчика цикла
    mov dword [i], 1             ; Устанавливаем начальное значение i = 1

main_loop:
    ; Проверка условия завершения цикла
    mov eax, [i]                 ; Загружаем текущее значение i
    cmp eax, [n]                 ; Сравниваем i с n
    jg program_end               ; Если i > n, завершаем программу

    ; Вычисление квадрата текущего числа
    mov eax, [i]                 ; Загружаем число i
    movsxd rax, eax              ; Знаково расширяем до 64 бит
    imul rax, rax                ; Умножаем число на себя (i * i)
    mov [square], rax            ; Сохраняем квадрат в переменную

    ; Подсчет количества цифр в числе i
    mov eax, [i]                 ; Загружаем число i
    mov [temp], eax              ; Сохраняем копию во временную переменную
    mov dword [digits], 0        ; Обнуляем счетчик цифр
count_digits:
    mov eax, [temp]              ; Загружаем текущее значение
    test eax, eax                ; Проверяем, не равно ли нулю
    jz digits_done               ; Если ноль - выходим из цикла
    inc dword [digits]           ; Увеличиваем счетчик цифр на 1
    xor edx, edx                 ; Обнуляем EDX для деления
    mov ecx, 10                  ; Устанавливаем делитель 10
    div ecx                      ; Делим EAX на 10
    mov [temp], eax              ; Сохраняем результат деления
    jmp count_digits             ; Продолжаем подсчет цифр
digits_done:

    ; Вычисление 10^digits (степени 10)
    mov qword [power], 1         ; Инициализируем степень единицей
    mov ecx, [digits]            ; Загружаем количество цифр
    test ecx, ecx                ; Проверяем, не равно ли нулю
    jz check_automorphic         ; Если digits = 0, пропускаем вычисления
compute_power:
    mov rax, [power]             ; Загружаем текущее значение степени
    mov rbx, 10                  ; Устанавливаем множитель 10
    mul rbx                      ; Умножаем текущую степень на 10
    mov [power], rax             ; Сохраняем новое значение степени
    dec ecx                      ; Уменьшаем счетчик цикла
    jnz compute_power            ; Продолжаем пока ECX не станет 0

check_automorphic:
    ; Проверка является ли число автоморфным
    mov rax, [square]            ; Загружаем квадрат числа
    mov rbx, [power]             ; Загружаем степень 10
    test rbx, rbx                ; Проверяем, не равно ли power нулю
    jz next_number               ; Если power = 0, пропускаем проверку
    xor rdx, rdx                 ; Обнуляем RDX для деления
    div rbx                      ; Делим квадрат на степень 10
    mov eax, [i]                 ; Загружаем исходное число i
    cmp edx, eax                 ; Сравниваем остаток с исходным числом
    jne next_number              ; Если не равны - не автоморфное число

    ; Вывод найденного автоморфного числа
    call print_simple_number     ; Вызываем процедуру вывода

next_number:
    ; Переход к следующему числу
    inc dword [i]                ; Увеличиваем счетчик i на 1
    jmp main_loop                ; Возвращаемся к началу цикла

print_simple_number:
    ; Процедура вывода автоморфного числа и его квадрата
    mov eax, [i]                 ; Загружаем число i
    call print_number            ; Вызываем процедуру вывода числа
    mov rax, 1                   ; Системный вызов write
    mov rdi, 1                   ; stdout
    mov rsi, separator           ; Указатель на разделитель
    mov rdx, separator_len       ; Длина разделителя
    syscall                      ; Вывод разделителя " - "
    mov rax, [square]            ; Загружаем квадрат числа
    call print_number64          ; Вызываем процедуру вывода 64-битного числа
    mov rax, 1                   ; Системный вызов write
    mov rdi, 1                   ; stdout
    mov rsi, newline             ; Указатель на символ новой строки
    mov rdx, 1                   ; Длина 1 символ
    syscall                      ; Вывод новой строки
    ret                          ; Возврат из процедуры

print_number:
    ; Процедура вывода 32-битного числа
    push rax                     ; Сохраняем регистры в стеке
    push rbx
    push rcx
    push rdx
    push rdi
    push rsi
    mov rcx, num_buf + 19        ; Устанавливаем указатель на конец буфера
    mov byte [rcx], 0            ; Добавляем нулевой терминатор
    dec rcx                      ; Перемещаемся на одну позицию назад
    test eax, eax                ; Проверяем, не равно ли число нулю
    jnz .convert                 ; Если не ноль - переходим к преобразованию
    mov byte [rcx], '0'          ; Для числа 0 записываем символ '0'
    dec rcx                      ; Перемещаемся назад
    jmp .print                   ; Переходим к выводу
.convert:
    xor edx, edx                 ; Обнуляем EDX для деления
    mov ebx, 10                  ; Устанавливаем делитель 10
    div ebx                      ; Делим EAX на 10
    add dl, '0'                  ; Преобразуем остаток в символ ASCII
    mov [rcx], dl                ; Сохраняем символ в буфер
    dec rcx                      ; Перемещаемся к предыдущей позиции
    test eax, eax                ; Проверяем, не стало ли частное нулем
    jnz .convert                 ; Если не ноль - продолжаем преобразование
.print:
    inc rcx                      ; Перемещаемся к первому символу числа
    mov rsi, rcx                 ; Устанавливаем указатель на начало строки
    mov rdx, num_buf + 20        ; Вычисляем конец буфера
    sub rdx, rcx                 ; Вычисляем длину строки
    mov rax, 1                   ; Системный вызов write
    mov rdi, 1                   ; stdout
    syscall                      ; Вывод числа
    pop rsi                      ; Восстанавливаем регистры из стека
    pop rdi
    pop rdx
    pop rcx
    pop rbx
    pop rax
    ret                          ; Возврат из процедуры

print_number64:
    ; Процедура вывода 64-битного числа
    push rax                     ; Сохраняем регистры в стеке
    push rbx
    push rcx
    push rdx
    push rdi
    push rsi
    mov rcx, num_buf + 19        ; Устанавливаем указатель на конец буфера
    mov byte [rcx], 0            ; Добавляем нулевой терминатор
    dec rcx                      ; Перемещаемся на одну позицию назад
    test rax, rax                ; Проверяем, не равно ли число нулю
    jnz .convert                 ; Если не ноль - переходим к преобразованию
    mov byte [rcx], '0'          ; Для числа 0 записываем символ '0'
    dec rcx                      ; Перемещаемся назад
    jmp .print                   ; Переходим к выводу
.convert:
    xor rdx, rdx                 ; Обнуляем RDX для деления
    mov rbx, 10                  ; Устанавливаем делитель 10
    div rbx                      ; Делим RAX на 10
    add dl, '0'                  ; Преобразуем остаток в символ ASCII
    mov [rcx], dl                ; Сохраняем символ в буфер
    dec rcx                      ; Перемещаемся к предыдущей позиции
    test rax, rax                ; Проверяем, не стало ли частное нулем
    jnz .convert                 ; Если не ноль - продолжаем преобразование
.print:
    inc rcx                      ; Перемещаемся к первому символу числа
    mov rsi, rcx                 ; Устанавливаем указатель на начало строки
    mov rdx, num_buf + 20        ; Вычисляем конец буфера
    sub rdx, rcx                 ; Вычисляем длину строки
    mov rax, 1                   ; Системный вызов write
    mov rdi, 1                   ; stdout
    syscall                      ; Вывод числа
    pop rsi                      ; Восстанавливаем регистры из стека
    pop rdi
    pop rdx
    pop rcx
    pop rbx
    pop rax
    ret                          ; Возврат из процедуры

program_end:
    ; Завершение программы
    mov rax, 60                  ; Системный вызов exit (60)
    xor rdi, rdi                 ; Код возврата 0
    syscall                      ; Завершение программы